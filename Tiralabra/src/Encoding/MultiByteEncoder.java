/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package Encoding;

import Dictionary.MultiByteHashedTable;
import MultiByteEntities.MultiByte;

/**
 *
 * @author virta
 */
public class MultiByteEncoder implements Runnable {

    /**
     * A Hashed table for multibyte data.
     */
    private MultiByteHashedTable hashTable;
    /**
     * The data read from file.
     */
    private byte[] data;
    /**
     * Current bytewidth to use in constructing multibytes.
     */
    private int byteWidth;
    /**
     * Array into which the encoded data is put.
     */
    private byte[] encodedData;
    /**
     * Array into ehich the encoded keys are put.
     */
    private byte[] encodedKeys;
    /**
     * Keys which are generated by the hashtable.
     */
    private MultiByte[] keys;
    /**
     * String for querying the status of operations.
     */
    private StatusEnum status;
    /**
     * Used to stop current operations. Can be accessed by hashtable in static context.
     */
    public static boolean interrupt;

    /**
     * Data to be encoded is given as a parameter, as is the width of the
     * sliding window.
     *
     * @param data
     * @param width
     */
    public MultiByteEncoder(byte[] data, int width) {
        this.byteWidth = width;
        this.data = data;
        this.hashTable = new MultiByteHashedTable();
        this.status = StatusEnum.NULL;
        MultiByteEncoder.interrupt = false;
    }

    public byte[] getEncodedKeys() {
        return this.encodedKeys;
    }

    public byte[] getEncodedData() {
        return this.encodedData;
    }

    public StatusEnum getStatus() {
        return this.status;
    }

    public void interrupt() {
        MultiByteEncoder.interrupt = true;
    }

    /**
     * Builds and returns a byte array of the encoded keys and data.
     *
     * @return
     */
    public byte[] getCombinedEncodedKeysAndData() {
        byte[] comined = new byte[encodedKeys.length + encodedData.length];
        int combinedIndex = 0;

        for (int i = 0; i < encodedKeys.length; i++) {
            comined[combinedIndex] = encodedKeys[i];
            combinedIndex++;
        }
        for (int i = 0; i < encodedData.length; i++) {
            comined[combinedIndex] = encodedData[i];
            combinedIndex++;
        }

        return comined;
    }

    /**
     * After calling thread.start() for the thread that envelopes this class the
     * encoding process starts. A hashed set of the data is made and remainder
     * is stored. Keys from the sorted and cleaned hash set are made and
     * encoded, and finally the data is encoded, keytable is not encoded into
     * the data at this stage.
     */
    @Override
    public void run() {
        this.status = StatusEnum.BUILDING;
        byte[] remainder = makeHashSet();

        if (interrupt) {
            this.status = StatusEnum.INTERRUPTED;
            return;
        }

        if (!makeAndCleanKeys()){
            this.status = StatusEnum.DATAERROR;
            return;
        }
        
        if (interrupt) {
            this.status = StatusEnum.INTERRUPTED;
            return;
        }

        this.status = StatusEnum.ENCODING;
        encodeKeys();

        if (interrupt) {
            this.status = StatusEnum.INTERRUPTED;
            return;
        }

        encodeData(remainder);

        this.status = StatusEnum.DONE;

    }

    /**
     * Creates a new bytearray for the encoded data, and encodes the data into
     * it. Data of the length bytewidth is read from the original data and a
     * multibyte is formed, if the hashtable contains the aforementioned
     * multibyte the keytable is searched for its index (key). If the data is is
     * not found in the hashtable the keytable will not have it either and the
     * data is not encoded. If a key is found it will be encoded in place of the
     * data. This method employs a form of run-length encoding: a prefix is
     * formed only when the current byte- width of the key differs from the
     * previous one, ie if keysize (in bytes) is different or no key is used.
     * Also multiple lengths of sequential unencoded data are encoded only one
     * prefix and it is changed only when the count reaches 86 or a key for data
     * is found.
     *
     * @param remainder
     * @return
     */
    private void encodeData(byte[] remainder) {

        encodedData = new byte[data.length];

        int bytesPerPreviousKey = -1;
        int bytesPerNextKey = 0;
        int runLength = 1;
        int prefixIndex = 0;
        int encodedDataIndex = 1;
        boolean newPrefix = false;

        encodedDataIndex = encodeRemainderToBegginning(remainder, encodedDataIndex, prefixIndex);
        prefixIndex=encodedDataIndex;
        encodedDataIndex++;

        for (int i = 0; i < data.length; i += byteWidth) {

            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                return;
            }

            MultiByte mb = makeMultiByte(i);

            if (mb != null && hashTable.contains(mb)) {
                int keyInteger = getkey(mb);
                int thisKeyByteSize = getBytesPerKey(keyInteger);
                byte[] keyBytes = ByteConversion.IntegerConverter.IntegerToByte(keyInteger, thisKeyByteSize);
                thisKeyByteSize = keyBytes.length;

                if (thisKeyByteSize == bytesPerPreviousKey && runLength < 9) {
                    runLength++;
                } else {
                    bytesPerNextKey = thisKeyByteSize;
                    bytesPerPreviousKey = bytesPerPreviousKey == -1 ? thisKeyByteSize : bytesPerPreviousKey;
                    newPrefix = true;
                }

                encodedDataIndex = encodeIntoArray(keyBytes, encodedData, encodedDataIndex);

            } else {
                if (bytesPerPreviousKey == 0 && runLength < 86) {
                    runLength++;
                } else {
                    bytesPerNextKey = 0;
                    bytesPerPreviousKey = bytesPerPreviousKey == -1 ? 0 : bytesPerPreviousKey;
                    newPrefix = true;
                }

                if (mb != null) {
                    encodedDataIndex = encodeIntoArray(mb.getBytes(), encodedData, encodedDataIndex);
                } else {
                    newPrefix = true;
                }

            }

            if (newPrefix) {
                int prefixInt = generatePrefixInteger(bytesPerPreviousKey, runLength);

                byte prefix = ByteConversion.IntegerConverter.IntegerToByte(prefixInt, 1)[0];
                encodedData[prefixIndex] = prefix;
                prefixIndex = encodedDataIndex;
                encodedDataIndex++;
                bytesPerPreviousKey = bytesPerNextKey;
                runLength = 1;

                newPrefix = false;
            }

        }

        encodedData = removeTrailingZeros(encodedData, encodedDataIndex);
    }

    /**
     * Removes trailing zeros from the supplied array ending at the last index.
     *
     * @param encodedData
     * @param lastIndex
     * @return
     */
    private byte[] removeTrailingZeros(byte[] encodedData, int lastIndex) {
        byte[] trimmed = new byte[lastIndex];
        for (int i = 0; i < trimmed.length; i++) {
            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                break;
            }

            trimmed[i] = encodedData[i];
        }
        return trimmed;
    }

    /**
     * Enoces any supplied data into the supplied data array beginning at the
     * supplied index.
     *
     * @param data
     * @param dataArray
     * @param dataIndex
     * @return
     */
    private int encodeIntoArray(byte[] data, byte[] dataArray, int dataIndex) {
        for (int i = 0; i < data.length; i++) {
            dataArray[dataIndex] = data[i];
            dataIndex++;
        }
        return dataIndex;
    }

    /**
     * Calculates the approximate byte-width for the supplied integer.
     *
     * @param key
     * @return
     */
    private int getBytesPerKey(int key) {
        if (key == 1) {
            return 1;
        }
        int bytes = 0;
        double k = key;
        while (k > 1) {
            k /= 255;
            bytes++;
        }
        return bytes;
    }

    /**
     * Searches the key-table for the supplied MultiByte and returns its index
     * as key.
     *
     * @param mb
     * @return the index for the multibyte if found, -1 if not found which
     * should never happen.
     */
    private int getkey(MultiByte mb) {
        for (int i = 0; i < keys.length; i++) {
            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                break;
            }

            if (keys[i].equals(mb)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Introduces to the hash table multibytes of the size bytewidth.
     *
     * @return
     */
    private byte[] makeHashSet() {
        byte[] remainder = null;

        for (int i = 0; i < data.length; i += byteWidth) {
            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                break;
            }

            if (i + byteWidth - 1 < data.length) {
                MultiByte mb = makeMultiByte(i);
                hashTable.put(mb);
            } else {
                remainder = new byte[data.length - i];
                for (int j = 0; j < remainder.length; j++) {
                    remainder[j] = data[i + j];   // if there is data left in the data-array, it is put in a new array and returned.
                }
            }
            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                break;
            }
        }
        return remainder;
    }

    /**
     * Calls the hashtable function to purge and clean keys that are not
     * referenced enough. Then purges from the set keys that would take more
     * space (table-entry + prefix + key) encoded than the data it encodes. This
     * is to guarantee that a key to be encoded will save at least 1 byte of
     * space when it is referenced at least the amount described below. A key to
     * be encoded will have a maximum of bytediwth-2 bytes, and the prefix for
     * data is in the worst case 1 byte. The reference count for any multibyte
     * is thus defined by the equation: bytewidth + 1, and the maximum number of
     * keys by: 2 ^ ( (bytewidth-2) *8 ).
     */
    private boolean makeAndCleanKeys() {
        hashTable.purgeAndClean(byteWidth);
        if (hashTable.getKeyCount()>0) {
            keys = hashTable.getArray(byteWidth);
            return true;
        }
        return false;
    }

    /**
     * Creates a bytearray of the keys stored in the global MultiByte array
     * keys.
     *
     * @return
     */
    private void encodeKeys() {
        encodedKeys = new byte[keys.length * byteWidth];
        int encodeIndex = 0;
        for (int i = 0; i < keys.length; i++) {
            byte[] keyData = keys[i].getBytes();
            for (int j = 0; j < keyData.length; j++) {
                if (interrupt) {
                    this.status = StatusEnum.INTERRUPTED;
                    return;
                }

                encodedKeys[encodeIndex] = keyData[j];
                encodeIndex++;
            }
        }
    }

    /**
     * Makes a multibyte out of the data-array beginning at the supplied index.
     *
     * @param dataIndex
     * @return a new multibyte with the data from the array if there was enough
     * data. Null if there was not enough data.
     */
    private MultiByte makeMultiByte(int dataIndex) {
        if (dataIndex + byteWidth - 1 < data.length) {
            MultiByte mb = new MultiByte(byteWidth);
            for (int j = 0; j < byteWidth; j++) {
                mb.addData(data[dataIndex + j]);
            }
            return mb;
        }
        return null;
    }

    /**
     * Generates an integer based on the bytewidth of previous key.
     *
     * @param bytesPerPreviousKey
     * @param runLength
     * @return an integer in the format: values 1 through 169 are reserved for
     * keys, first two digits represent byte-width of key, last the run-length;
     * values 170 through 255 are reserved for unencoded data, and represent
     * solely the running length for current bytewidth data. Currently the
     * maximum bytewidth for a key is limited to 16.
     */
    private int generatePrefixInteger(int bytesPerPreviousKey, int runLength) {
        int prefixInt;
        if (bytesPerPreviousKey == 0) {
            prefixInt = 169 + runLength;
        } else {
            prefixInt = bytesPerPreviousKey * 10 + runLength;
        }
        return prefixInt;
    }

    /**
     * Encodes the remainder of raw data into the begginning of the data.
     *
     * @param remainder
     * @param encodedDataIndex
     * @param prefixIndex
     * @return
     */
    private int encodeRemainderToBegginning(byte[] remainder, int encodedDataIndex, int prefixIndex) {
        byte rawPrefix;
        if (remainder != null) {
            rawPrefix = ByteConversion.IntegerConverter.IntegerToByte(remainder.length, 1)[0];
            encodedDataIndex = encodeIntoArray(remainder, encodedData, encodedDataIndex);
        } else {
            rawPrefix = new Byte("0");
        }
        encodedData[prefixIndex] = rawPrefix;
        return encodedDataIndex;
    }

    public enum StatusEnum {

        NULL,
        BUILDING,
        ENCODING,
        DONE,
        DATAERROR,
        INTERRUPTED
    }
}
