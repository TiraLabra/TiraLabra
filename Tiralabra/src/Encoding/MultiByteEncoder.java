/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package Encoding;

import Utilities.*;
import Dictionary.MultiByteHashedTable;
import MultiByteEntities.MultiByte;

/**
 * Implementing the Runnable interface, this class may be run in a separate thread after construction.
 * 
 * @author virta
 */
public class MultiByteEncoder implements Runnable {

    /**
     * A Hashed table for multibyte data.
     */
    private MultiByteHashedTable hashTable;
    /**
     * The data read from file.
     */
    private byte[] data;
    /**
     * Current bytewidth to use in constructing multibytes.
     */
    private int byteWidth;
    /**
     * Array into which the encoded data is put.
     */
    private byte[] encodedData;
    /**
     * Array into ehich the encoded keys are put.
     */
    private byte[] encodedKeys;
    /**
     * Keys which are generated by the hashtable.
     */
    private MultiByte[] keys;
    /**
     * String for querying the status of operations.
     */
    private StatusEnum status;
    /**
     * Used to stop current operations. Can be accessed by hashtable in static
     * context.
     */
    public boolean interrupt;

    /**
     * Data to be encoded is given as a parameter, as is the width of the
     * sliding window.
     *
     * @param data
     * @param width
     */
    public MultiByteEncoder(byte[] data, int width) {
        this.byteWidth = width;
        this.data = data;
        this.status = StatusEnum.NULL;
        this.interrupt = false;
        this.hashTable = new MultiByteHashedTable(this);
    }

    public byte[] getEncodedKeys() {
        return this.encodedKeys;
    }

    public byte[] getEncodedData() {
        return this.encodedData;
    }

    public StatusEnum getStatus() {
        return this.status;
    }

    public void interrupt() {
        this.interrupt = true;
    }
    
    public boolean isInterrupted(){
        return this.interrupt;
    }
    /**
     * Builds and returns a byte array of the encoded keys and data with a table header.
     *
     * @return
     */
    public byte[] getCombinedEncodedKeysAndData() {
                
        byte[] header = makeHeader();
        
        byte[] combined = new byte[encodedKeys.length + encodedData.length + header.length];
        int combinedIndex = 0;

        combinedIndex = ArrayUtilities.encodeIntoArray(header, combined, combinedIndex);
        
        combinedIndex = ArrayUtilities.encodeIntoArray(encodedKeys, combined, combinedIndex);
        
        ArrayUtilities.encodeIntoArray(encodedData, combined, combinedIndex);
        
        return combined;
    }

    /**
     * After calling thread.start() for the thread that envelopes this class the
     * encoding process starts. A hashed set of the data is made and remainder
     * is stored. Keys from the sorted and cleaned hash set are made and
     * encoded, and finally the data is encoded, keytable is not encoded into
     * the data at this stage.
     */
    @Override
    public void run() {
        this.status = StatusEnum.BUILDING;
        byte[] remainder = makeHashSet();

        if (interrupt) {
            this.status = StatusEnum.INTERRUPTED;
            return;
        }

        if (!makeAndCleanKeys()) {
            this.status = StatusEnum.DATAERROR;
            return;
        }

        if (interrupt) {
            this.status = StatusEnum.INTERRUPTED;
            return;
        }

        this.status = StatusEnum.ENCODING;
        encodeKeys();

        if (interrupt) {
            this.status = StatusEnum.INTERRUPTED;
            return;
        }

        if (!encodeData(remainder)){
            return;
        }

        this.status = StatusEnum.DONE;

    }

    /**
     * Creates a new bytearray for the encoded data, and encodes the data into
     * it. Data of the length bytewidth is read from the original data and a
     * multibyte is formed, if the hashtable contains the aforementioned
     * multibyte the keytable is searched for its index (key). If the data is is
     * not found in the hashtable the keytable will not have it either and the
     * data is not encoded. If a key is found it will be encoded in place of the
     * data. This method employs a form of run-length encoding: a prefix is
     * formed only when the current byte- width of the key differs from the
     * previous one, ie if keysize (in bytes) is different or no key is used.
     * Also multiple lengths of sequential unencoded data are encoded only one
     * prefix and it is changed only when the count reaches 86 or a key for data
     * is found.
     *
     * @param remainder
     * @return
     */
    private boolean encodeData(byte[] remainder) {

        encodedData = new byte[data.length];

        int bytesPerPreviousKey = -1;   //initial value, tells algorithm to create the first prefix
        int bytesPerNextKey = 0;        //after initializing the first prefix gets the value -1 to tell algorithm not to reinitalize first prefix but to continue to the next bytewidth of data.
        int runLength = 1;              //run-length for current bytewidth of key or raw data.
        int prefixIndex = 0;
        int encodedDataIndex = 0;
        boolean newPrefix = false;
        boolean makeLastPrefix = true;

        byte[] remainderWithPrefix = makeRemainderWithPrefix(remainder);
        prefixIndex = ArrayUtilities.encodeIntoArray(remainderWithPrefix, encodedData, prefixIndex);
        encodedDataIndex = prefixIndex;

        for (int i = 0; i < data.length; i += byteWidth) {

            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                return false;
            }

            MultiByte mb = ArrayUtilities.makeMultiByte(i, data, byteWidth);
            
            if (mb != null && hashTable.contains(mb) ) {
                int keyInteger = getkey(mb);                //there is a key for the multibyte, fetch it.
                
                if (keyInteger == -1){                          //if there was no key for the multibyte, should NEVER happen.
                    this.status = StatusEnum.DATAERROR;
                    return false;
                }
                
                int thisKeyByteSize = IntegerConverter.getBytesPerInteger(keyInteger);
                byte[] keyBytes = IntegerConverter.IntegerToByte(keyInteger, thisKeyByteSize);
                thisKeyByteSize = keyBytes.length;
                
                if (keyInteger == 0){                           //if hte key was 0, ie the multi-byte was in the first index, make an array for it, as zero is otherwise 0 length.
                    thisKeyByteSize = 1;
                    keyBytes = new byte[]{new Byte("0")};
                }

                if (thisKeyByteSize == bytesPerPreviousKey && runLength < 9 && bytesPerNextKey != -1) {     //if keys' bytesize matches and initializations have been done
                    runLength++;
                    
                } else if (bytesPerPreviousKey == -1) {                 //initialization, always create the first prefix.
                    bytesPerNextKey = -1;
                    bytesPerPreviousKey = thisKeyByteSize;
                    encodedDataIndex++;
                    newPrefix = true;
                    
                } else if (bytesPerNextKey == -1){                      //if initialized, continue to the next byteiwdth of data.
                    bytesPerPreviousKey = thisKeyByteSize;
                    bytesPerNextKey = thisKeyByteSize;
                    encodedDataIndex++;
                    
                } else {
                    bytesPerNextKey = thisKeyByteSize;
                    int multiplier = bytesPerPreviousKey == 0 ? byteWidth : bytesPerPreviousKey;        //calculate index multiplier for the prefix to be formed
                    prefixIndex = encodedDataIndex - (runLength*multiplier) - 1;                        //the actual index for the prefix, based on previous keys' bytewidth and runlength.
                    encodedDataIndex++;
                    newPrefix = true;
                }

                encodedDataIndex = ArrayUtilities.encodeIntoArray(keyBytes, encodedData, encodedDataIndex);     //For some reason fails if bytewidth is uneven

            } else {
                
                if (bytesPerPreviousKey == 0 && runLength < 86 && bytesPerNextKey != -1) {
                    runLength++;
                    
                } else if (bytesPerPreviousKey == -1) {
                    bytesPerNextKey = -1;
                    bytesPerPreviousKey = 0;
                    encodedDataIndex++;
                    newPrefix = true;
                    
                } else if (bytesPerNextKey == -1){
                    bytesPerPreviousKey = 0;
                    bytesPerNextKey = 0;
                    encodedDataIndex++;
                    
                } else {
                    bytesPerNextKey = 0;
                    int multiplier = bytesPerPreviousKey == 0 ? byteWidth : bytesPerPreviousKey;
                    prefixIndex = encodedDataIndex - (runLength*multiplier) - 1;
                    encodedDataIndex++;
                    newPrefix = true;
                }
                
                if (mb != null) {
                    encodedDataIndex = ArrayUtilities.encodeIntoArray(mb.getBytes(), encodedData, encodedDataIndex);       //For some reason fails if bytewidth is uneven
                } else {                //the last data is the remainder and is not encoded, make a new prefix but don't make the last prefix as it would mess things up, also subtract one from encoding index so array is properly contrated
                    newPrefix = true;
                    makeLastPrefix = false;
                    encodedDataIndex--;
                }

            }

            if (newPrefix) {
                int prefixInt = generatePrefixInteger(bytesPerPreviousKey, runLength);

                byte prefix = IntegerConverter.IntegerToByte(prefixInt, 1)[0];
                encodedData[prefixIndex] = prefix;
                if (bytesPerNextKey != -1) {
                    bytesPerPreviousKey = bytesPerNextKey;          //if algorithm has moved past initializations.
                }
                runLength = 1;
                newPrefix = false;
            }

        }
        
        // make the last prefix
        if (makeLastPrefix) {
            int multiplier = bytesPerPreviousKey == 0 ? byteWidth : bytesPerPreviousKey;
            prefixIndex = encodedDataIndex - (runLength * multiplier) - 1;
            int prefixInt = generatePrefixInteger(bytesPerPreviousKey, runLength);
            byte prefix = IntegerConverter.IntegerToByte(prefixInt, 1)[0];
            encodedData[prefixIndex] = prefix;
        }

        encodedData = ArrayUtilities.removeTrailingZeros(encodedData, encodedDataIndex);
        
        return true;
    }

    /**
     * Searches the key-table for the supplied MultiByte and returns its index
     * as key.
     *
     * @param mb
     * @return the index for the multibyte if found, -1 if not found which
     * should never happen.
     */
    private int getkey(MultiByte mb) {
        for (int i = 0; i < keys.length; i++) {
            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                break;
            }

            if (keys[i].equals(mb)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Introduces to the hash table multibytes of the size bytewidth.
     *
     * @return
     */
    private byte[] makeHashSet() {
        byte[] remainder = null;

        for (int i = 0; i < data.length; i += byteWidth) {
            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                break;
            }

            if (i + byteWidth - 1 < data.length) {
                MultiByte mb = ArrayUtilities.makeMultiByte(i, data, byteWidth);
                hashTable.put(mb);
            } else {
                remainder = new byte[data.length - i];
                for (int j = 0; j < remainder.length; j++) {
                    remainder[j] = data[i + j];   // if there is data left in the data-array, it is put in a new array and returned.
                }
            }
            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                break;
            }
        }
        return remainder;
    }

    /**
     * Calls the hashtable function to purge and clean keys that are not
     * referenced enough. Then purges from the set keys that would take more
     * space (table-entry + prefix + key) encoded than the data it encodes. This
     * is to guarantee that a key to be encoded will save at least 1 byte of
     * space when it is referenced at least the amount described below. A key to
     * be encoded will have a maximum of bytediwth-2 bytes, and the prefix for
     * data is in the worst case 1 byte. The reference count for any multibyte
     * is thus defined by the equation: bytewidth + 1, and the maximum number of
     * keys by: 2 ^ ( (bytewidth-2) *8 ).
     * @return true if there are more than zero keys false otherwise. There might
     * be zero keys if the data is almost random and not enough references are made
     * to any keys.
     */
    private boolean makeAndCleanKeys() {
        hashTable.purgeAndClean(byteWidth);
        if (hashTable.getKeyCount() > 0) {
            keys = hashTable.getSortedArray(byteWidth);
            return true;
        }
        return false;
    }

    /**
     * Creates a bytearray of the keys stored in the global MultiByte array:
     * keys.
     *
     * @return
     */
    private void encodeKeys() {
        encodedKeys = new byte[keys.length * byteWidth];
        int encodeIndex = 0;
        for (int i = 0; i < keys.length; i++) {
            byte[] keyData = keys[i].getBytes();
            
            encodeIndex = ArrayUtilities.encodeIntoArray(keyData, encodedKeys, encodeIndex);

        }
    }

    /**
     * Generates an integer based on the bytewidth of previous key.
     *
     * @param bytesPerPreviousKey
     * @param runLength
     * @return an integer in the format: values 1 through 169 are reserved for
     * keys, first two digits represent byte-width of key, last the run-length;
     * values 170 through 255 are reserved for unencoded data, and represent
     * solely the running length for current bytewidth data. Currently the
     * maximum bytewidth for a key is limited to 16.
     */
    private int generatePrefixInteger(int bytesPerPreviousKey, int runLength) {
        int prefixInt;
        if (bytesPerPreviousKey == 0) {
            prefixInt = 169 + runLength;
        } else {
            prefixInt = bytesPerPreviousKey * 10 + runLength;
        }
        return prefixInt;
    }

    /**
     * Encodes the remainder of raw data into the begginning of the data.
     *
     * @param data
     * @param encodedDataIndex
     * @param prefixIndex
     * @return
     */
    private byte[] makeRemainderWithPrefix(byte[] remainder) {
        byte rawPrefix;
        byte[] remainderAndPrefix;
        if (remainder != null) {
            rawPrefix = IntegerConverter.IntegerToByte(remainder.length, 1)[0];
            remainderAndPrefix = new byte[1+remainder.length];
            remainderAndPrefix[0] = rawPrefix;
            
            ArrayUtilities.encodeIntoArray(remainder, remainderAndPrefix, 1);

        } else {
            remainderAndPrefix = new byte[]{ new Byte("0") };
        }
        
        return remainderAndPrefix;
    }

    /**
     * Creates a header for the table in byte format. First byte is bytewidth, next bytes are
     * the size of the keytable and the last byte is zero denoting the end of the header.
     * @return 
     */
    private byte[] makeHeader() {
        byte byteWidthByte = IntegerConverter.IntegerToByte(byteWidth, 1)[0];
        
        int keyTableSizeByteCount = IntegerConverter.getBytesPerInteger(encodedKeys.length);
        byte[] keyTableSize = IntegerConverter.IntegerToByte(encodedKeys.length, keyTableSizeByteCount);
        
        byte[] header = new byte[keyTableSize.length + 2];
        header[0] = byteWidthByte;
        Utilities.ArrayUtilities.encodeIntoArray(keyTableSize, header, 1);
        
//        for (int i = 1; i < header.length-1; i++) {
//            header[i] = keyTableSize[i-1];
//        }
        header[header.length-1] = new Byte("0");
        
        return header;
    }

}
