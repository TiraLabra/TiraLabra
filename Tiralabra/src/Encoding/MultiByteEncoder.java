/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package Encoding;

import Dictionary.MultiByteHashedTable;
import MultiByteEntities.MultiByte;

/**
 *
 * @author virta
 */
public class MultiByteEncoder implements Runnable {

    /**
     * A Hashed table for multibyte data.
     */
    private MultiByteHashedTable hashTable;
    /**
     * The data read from file.
     */
    private byte[] data;
    /**
     * Current bytewidth to use in constructing multibytes.
     */
    private int byteWidth;
    /**
     * Array into which the encoded data is put.
     */
    private byte[] encodedData;
    /**
     * Array into ehich the encoded keys are put.
     */
    private byte[] encodedKeys;
    /**
     * Keys which are generated by the hashtable.
     */
    private MultiByte[] keys;

    /**
     * Data to be encoded is given as a parameter, as is the width of the
     * sliding window.
     *
     * @param data
     * @param width
     */
    public MultiByteEncoder(byte[] data, int width) {
        this.byteWidth = width;
        this.data = data;
        this.hashTable = new MultiByteHashedTable();
    }

    /**
     * After calling thread.start() for the thread that envelopes this class
     * the encoding process starts. A hashed set of the data is made and
     * remainder is stored. Keys from the sorted and cleaned hash set are made and encoded,
     * and finally the data is encoded, keytable is not encoded into the data at 
     * this stage.
     */
    @Override
    public void run() {

        byte[] remainder = makeHashSet();

        makeAndCleanKeys();

        encodedKeys = encodeKeys();

        encodedData = encodeData(remainder);

    }

    /**
     * Creates a new bytearray for the encoded data, and encodes the data into it.
     * Data of the length bytewidth is read from the original data and a multibyte
     * is formed, if the hashtable contains the aforementioned multibyte the key-
     * table is searched for its index (key). If the data is is not found in the
     * hashtable the keytable will not have it either and the data is encoded as-is.
     * If a key is found it will be encoded in place of the data. This method employs
     * a form of run-length encoding: a prefix is formed only when the current byte-
     * width of the key differs from the previous one, ie if keysize (in bytes) is 
     * different or no key is used. Also multiple lengths of sequential
     * unencoded data are encoded only one prefix and it is changed only when the 
     * count reaches 86 or a key for data is found.
     * @param remainder
     * @return 
     */
    private byte[] encodeData(byte[] remainder) {

        encodedData = new byte[data.length];

        int bytesPerPreviousKey = -1;   //-1 denotes the starting bytewidth per key
        int bytesPerNextKey = 0;            //if a new bytewidth for the key is encountered it is stored here
        int runLength = 1;              //the running length of current bytewidth for key
        int prefixIndex = 0;                //the location into which a prefix is put when a new prefix is needed
        int encodedDataIndex = 1;       //the data encoding starts from the second bucket as the first bucket is reserved for the first prefix
        boolean newPrefix = false;
        
        encodedDataIndex = encodeRemainderToBegginning(remainder, encodedDataIndex, prefixIndex);        

        for (int i = 0; i < data.length; i += byteWidth) {      //look through all data for matching keys
            MultiByte mb = makeMultiByte(i);
            
            if (mb != null && hashTable.contains(mb)) {             //multibyte is null if not enough data in the array
                int keyInteger = getkey(mb);                    //the hashtable will contain the mb, and so will the local keytable
                int thisKeyByteSize = getBytesPerKey(keyInteger);
                byte[] keyBytes = ByteConversion.IntegerConverter.IntegerToByte(keyInteger, thisKeyByteSize);
                thisKeyByteSize = keyBytes.length;              //size of the key might be reduced in the previous method

                if (thisKeyByteSize == bytesPerPreviousKey && runLength < 9) {      //if the previous keysize was the same, use runlength encoding for current width, allow up to nine bytewidths of length
                    runLength++;
                } else {
                    bytesPerNextKey = thisKeyByteSize;          //next prefix is built with encoded-data format with this keysize
                    bytesPerPreviousKey = bytesPerPreviousKey == -1 ? thisKeyByteSize : bytesPerPreviousKey;        //initialize the variable for the first time to this run
                    newPrefix = true;                           //generate prefix
                }

                encodedDataIndex = encodeIntoArray(keyBytes, encodedData, encodedDataIndex);

            } else {                            //no key was found for current data or data is ending
                if (bytesPerPreviousKey == 0 && runLength < 86) {                   //if previous data is also raw use runlength, allow up to 86 bytewidths of length
                    runLength++;
                } else {
                    bytesPerNextKey = 0;        //next prefix is built with raw-data format
                    bytesPerPreviousKey = bytesPerPreviousKey == -1 ? 0 : bytesPerPreviousKey;                      //initialize the variable for the first time
                    newPrefix = true;
                }

                if (mb != null){                //if no key was found for the data
                    encodedDataIndex = encodeIntoArray(mb.getBytes(), encodedData, encodedDataIndex);
                } else {                        //if the data was too short to form a multibyte of current bytewidth make a new prefix and end loop
                    newPrefix = true;
                }

            }

            if (newPrefix) {
                int prefixInt = generatePrefixInteger(bytesPerPreviousKey, runLength);

                byte prefix = ByteConversion.IntegerConverter.IntegerToByte(prefixInt, 1)[0];
                encodedData[prefixIndex] = prefix;
                prefixIndex = encodedDataIndex;         //next prefix is put to the next location for data
                encodedDataIndex++;                     //and dataindex is advanced by one
                bytesPerPreviousKey = bytesPerNextKey;  //next prefix is formed with this format
                runLength = 1;

                newPrefix = false;
            }

        }
        
        encodedData = removeTrailingZeros(encodedData, encodedDataIndex);       //encoded data probably has trailing zeros.

        return encodedData;
    }
    
    /**
     * Removes trailing zeros from the supplied array ending at the last index.
     * @param encodedData
     * @param lastIndex
     * @return 
     */
    private byte[] removeTrailingZeros(byte[] encodedData, int lastIndex){
        byte[] trimmed = new byte[lastIndex];
        for (int i = 0; i < trimmed.length; i++) {
            trimmed[i] = encodedData[i];
        }
        return trimmed;
    }

    /**
     * Enoces any supplied data into the supplied data array beginning at the supplied index.
     * @param data
     * @param dataArray
     * @param dataIndex
     * @return 
     */
    private int encodeIntoArray(byte[] data, byte[] dataArray, int dataIndex) {
        for (int i = 0; i < data.length; i++) {
            dataArray[dataIndex] = data[i];
            dataIndex++;
        }
        return dataIndex;
    }

    /**
     * Calculates the approximate byte-width for the supplied integer.
     * @param key
     * @return 
     */
    private int getBytesPerKey(int key) {
        if (key == 1) {
            return 1;
        }
        int bytes = 0;
        double k = key;
        while (k > 1) {
            k /= 255;
            bytes++;
        }
        return bytes;
    }

    /**
     * Searches the key-table for the supplied MultiByte and returns its index as key.
     * @param mb
     * @return the index for the multibyte if found, -1 if not found which should never happen.
     */
    private int getkey(MultiByte mb) {
        for (int i = 0; i < keys.length; i++) {
            if (keys[i].equals(mb)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Introduces to the hash table multibytes of the size bytewidth.
     *
     * @return
     */
    private byte[] makeHashSet() {
        byte[] remainder = null;

        for (int i = 0; i < data.length; i += byteWidth) {
            if (i + byteWidth - 1 < data.length) {
                MultiByte mb = makeMultiByte(i);
                hashTable.put(mb);
            } else {
                remainder = new byte[data.length - i];
                for (int j = 0; j < remainder.length; j++) {
                    remainder[j] = data[i + j];   // if there is data left in the data-array, it is put in a new array and returned.
                }
            }
        }
        return remainder;
    }

    /**
     * Calls the hashtable function to purge and clean keys that are not
     * referenced enough. Then purges from the set keys that would take more
     * space (table-entry + prefix + key) encoded than the data it encodes. This
     * is to guarantee that a key to be encoded will save at least 1 byte of
     * space when it is referenced at least the amount described below. A key to
     * be encoded will have a maximum of bytediwth-2 bytes, and the prefix for
     * data is in the worst case 1 byte. The reference count for any multibyte
     * is thus defined by the equation: bytewidth + 1, and the maximum number of
     * keys by: 2 ^ ( (bytewidth-2) *8 ).
     */
    private void makeAndCleanKeys() {
        hashTable.purgeAndClean(byteWidth);
        keys = hashTable.getArray(byteWidth);
    }

    /**
     * Creates a bytearray of the keys stored in the global MultiByte array
     * keys.
     *
     * @return
     */
    private byte[] encodeKeys() {
        byte[] encodedKeys = new byte[keys.length * byteWidth];
        int encodeIndex = 0;
        for (int i = 0; i < keys.length; i++) {
            byte[] keyData = keys[i].getBytes();
            for (int j = 0; j < keyData.length; j++) {
                encodedKeys[encodeIndex] = keyData[j];
                encodeIndex++;
            }
        }
        return encodedKeys;
    }

    /**
     * Makes a multibyte out of the data-array beginning at the supplied index.
     * @param dataIndex
     * @return a new multibyte with the data from the array if there was enough data. Null if there was not enough data.
     */
    private MultiByte makeMultiByte(int dataIndex) {
        if (dataIndex + byteWidth - 1 < data.length) {
            MultiByte mb = new MultiByte(byteWidth);
            for (int j = 0; j < byteWidth; j++) {
                mb.addData(data[dataIndex + j]);
            }
            return mb;
        }
        return null;
    }

    /**
     * Generates an integer based on the bytewidth of previous key.
     * @param bytesPerPreviousKey
     * @param runLength
     * @return an integer in the format: values 1 through 169 are reserved for keys, first two digits represent byte-width of key, last the run-length;
     * values 170 through 255 are reserved for unencoded data, and represent solely the running length for current bytewidth data.
     */
    private int generatePrefixInteger(int bytesPerPreviousKey, int runLength) {
        int prefixInt;
        if (bytesPerPreviousKey == 0) {
            prefixInt = 169 + runLength;
        } else {
            prefixInt = bytesPerPreviousKey * 10 + runLength;
        }
        return prefixInt;
    }

    private int encodeRemainderToBegginning(byte[] remainder, int encodedDataIndex, int prefixIndex) throws NumberFormatException {
        byte rawPrefix = new Byte(""+remainder.length);
        encodedData[encodedDataIndex] = rawPrefix;
        encodedDataIndex++;
        encodedDataIndex = encodeIntoArray(remainder, encodedData, prefixIndex);        //put the remainder of the data in front of the encoded data with the prefix
        return encodedDataIndex;
    }
}
