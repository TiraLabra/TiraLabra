/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package Encoding;

import Dictionary.MultiByteHashedTable;
import MultiByteEntities.MultiByte;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 *
 * @author virta
 */
public class MultiByteEncoder implements Runnable {
    
    /**
     * A Hashed table for multibyte data.
     */
    private MultiByteHashedTable hashTable;
    
    /**
     * The data read from file.
     */
    private byte[] data;
    
    /**
     * Current bytewidth to use in constructing multibytes.
     */
    private int byteWidth;
    
    /**
     * Array into which the encoded data is put.
     */
    private byte[] encodedData;
    
    /**
     * Keys which are generated by the hashtable.
     */
    private MultiByte[] keys;
    
    /**
     * Data to be encoded is given as a parameter, as is the width of the sliding window.
     * @param data
     * @param width
     */
    public MultiByteEncoder(byte[] data, int width) {
        this.byteWidth = width;
        this.data = data;
        this.hashTable = new MultiByteHashedTable(data.length/width + (data.length%2));
    }
    
    @Override
    public void run() {
        
        byte[] remainder = makeHashSet();
        
        makeAndCleanKeys();
        
        byte[] encodedKeys = encodeKeys();
        
        byte[] encodedData = encodeData();
        
    }
    
    private byte[] encodeData(){
        return new byte[0];
    }
    
    /**
     * Purges from the keyset all keys that would take more space in encoded data than
     * unencoded data, that is keys under or equal to (bytewidth - 2) bytes long are kept.
     * @param numberOfKeys the number of keys to be kept.
     * @return a set of keys with oversized keys removed.
     */
    private MultiByte[] purgeOversizedKeys(int numberOfKeys){
        MultiByte[] newKeys = new MultiByte[numberOfKeys];
        for (int i = 0; i < numberOfKeys; i++) {
            newKeys[i] = keys[i];
        }
        return newKeys;
    }

    /**
     * Introduces to the hashed table multibytes of the size bytewidth.
     * @return 
     */
    private byte[] makeHashSet() {
        byte[] remainder = null;
        
        for (int i = 0; i < data.length; i+=byteWidth) {
            if (i+byteWidth-1 < data.length){
                MultiByte mb = new MultiByte(byteWidth);
                for (int j = 0; j < byteWidth; j++) {
                    mb.addData(data[i+j]);
                }
                hashTable.put(mb);
            } else {
                remainder = new byte[data.length-i];
                for (int j = 0; j < remainder.length; j++) {
                    remainder[j] = data[i+j];   // if there is data left in the data-array, it is put in a new array and returned.
                }
            }
        }
        return remainder;
    }

    /**
     * Calls the hashtable function to purge and clean keys that are not referenced enough.
     * Then purges from the set keys that would take more space (table-entry + prefix + key) 
     * encoded than the data it encodes.
     * This is to guarantee that a key to be encoded will save at least 1 byte of space
     * when it is referenced at least the amount described below.
     * A key to be encoded will have a maximum of bytediwth-1 bytes, and
     * the prefix for any data is 1 byte.
     * The reference count for any multibyte is thus defined by the equation:
     * bytewidth + (bytewidth - 2).
     * Furthermore, if there still are keys at the lower end of the table that would take
     * more space than the data they encode they are purged.
     */
    private void makeAndCleanKeys() {
        int minRefCount = byteWidth + (byteWidth-2);
        
        hashTable.purgeAndClean(minRefCount);
        keys = hashTable.getArray();
        
        int maxNumerOfKeys = (int) (Math.pow(2, ((byteWidth-2)*7)) - 1) * 2;
        
        if (keys.length > maxNumerOfKeys){
            keys = purgeOversizedKeys(maxNumerOfKeys);
        }
    }

    /**
     * Takes any integer and produces a bytearray which represents the integer.
     * @param key the key to be encoded in byte fashion.
     * @param byteCount the number of bytes it takes for the key.
     * @return a byte array representation of the given key.
     */
    private static byte[] intToByteArray(int key, int byteCount) {
        byte[] keyBytes = new byte[byteCount];
        int index = 0;
        for (int i = keyBytes.length-1; i >= 0; i--) {
            keyBytes[index] = (byte) ((key >> (8*i)) & 0xFF);   //start from the maximum number of iterations to account for higher shifting.
            index++;
        }
        return keyBytes;
//        return new byte[]{
//            (byte) ((key >> 24) & 0xFF),
//            (byte) ((key >> 16) & 0xFF),
//            (byte) ((key >> 8) & 0xFF),
//            (byte) (key & 0xFF)
//        };
    }

    /**
     * Calculates the number of bytes required to represent any integer.
     * @param i
     * @return 
     */
    private int getBytesPerKey(int i) {
        int key = i;
        int bytesPerKey = 0;
        while (key>1) {
            key/=256;
            bytesPerKey++;
        }
        return bytesPerKey;
    }

    /**
     * Creates a bytearray of the keys stored in the global MultiByte array keys.
     * @return 
     */
    private byte[] encodeKeys() {
        byte[] encodedKeys = new byte[data.length];
        int encodeIndex = 0;
        for (int i = 0; i < keys.length; i++) {
            int bytesPerKey = getBytesPerKey(i);
            byte[] keyBytes = intToByteArray(i, bytesPerKey);   //the first 256 keys will have one byte per key, and more bytes are added only as necessary.
            byte[] data = keys[i].getBytes();
            for (int j = 0; j < keyBytes.length; j++) {
                encodedKeys[encodeIndex] = keyBytes[j];
                encodeIndex++;
            }
            for (int j = 0; j < data.length; j++) {
                encodedKeys[encodeIndex] = data[j];
                encodeIndex++;
            }
        }
        return encodedKeys;
    }
}
