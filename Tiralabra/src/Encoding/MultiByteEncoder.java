/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package Encoding;

import Utilities.*;
import Dictionary.MultiByteHashedTable;
import MultiByteEntities.MultiByte;

/**
 * Implementing the Runnable interface, this class may be run in a separate thread after construction.
 * 
 * @author virta
 */
public class MultiByteEncoder implements Runnable {

    /**
     * A Hashed table for multibyte data.
     */
    private MultiByteHashedTable hashTable;
    /**
     * The data read from file.
     */
    private byte[] data;
    /**
     * Current bytewidth to use in constructing multibytes.
     */
    private int byteWidth;
    /**
     * Array into which the encoded data is put.
     */
    private byte[] encodedData;
    /**
     * Array into ehich the encoded keys are put.
     */
    private byte[] encodedKeys;
    /**
     * Keys which are generated by the hashtable.
     */
    private MultiByte[] keys;
    /**
     * String for querying the status of operations.
     */
    private StatusEnum status;
    /**
     * Used to stop current operations. Can be accessed by hashtable in static
     * context.
     */
    public static boolean interrupt;

    /**
     * Data to be encoded is given as a parameter, as is the width of the
     * sliding window.
     *
     * @param data
     * @param width
     */
    public MultiByteEncoder(byte[] data, int width) {
        this.byteWidth = width;
        this.data = data;
        this.hashTable = new MultiByteHashedTable();
        this.status = StatusEnum.NULL;
        MultiByteEncoder.interrupt = false;
    }

    public byte[] getEncodedKeys() {
        return this.encodedKeys;
    }

    public byte[] getEncodedData() {
        return this.encodedData;
    }

    public StatusEnum getStatus() {
        return this.status;
    }

    public void interrupt() {
        MultiByteEncoder.interrupt = true;
    }

    /**
     * Builds and returns a byte array of the encoded keys and data with a table header.
     *
     * @return
     */
    public byte[] getCombinedEncodedKeysAndData() {
                
        byte[] header = makeHeader();
        
        byte[] combined = new byte[encodedKeys.length + encodedData.length + header.length];
        int combinedIndex = 0;

        combinedIndex = ArrayUtilities.encodeIntoArray(header, combined, combinedIndex);
        
        combinedIndex = ArrayUtilities.encodeIntoArray(encodedKeys, combined, combinedIndex);
        
        ArrayUtilities.encodeIntoArray(encodedData, combined, combinedIndex);
        
        return combined;
    }

    /**
     * After calling thread.start() for the thread that envelopes this class the
     * encoding process starts. A hashed set of the data is made and remainder
     * is stored. Keys from the sorted and cleaned hash set are made and
     * encoded, and finally the data is encoded, keytable is not encoded into
     * the data at this stage.
     */
    @Override
    public void run() {
        this.status = StatusEnum.BUILDING;
        byte[] remainder = makeHashSet();

        if (interrupt) {
            this.status = StatusEnum.INTERRUPTED;
            return;
        }

        if (!makeAndCleanKeys()) {
            this.status = StatusEnum.DATAERROR;
            return;
        }

        if (interrupt) {
            this.status = StatusEnum.INTERRUPTED;
            return;
        }

        this.status = StatusEnum.ENCODING;
        encodeKeys();

        if (interrupt) {
            this.status = StatusEnum.INTERRUPTED;
            return;
        }

        encodeData(remainder);

        this.status = StatusEnum.DONE;

    }

    /**
     * Creates a new bytearray for the encoded data, and encodes the data into
     * it. Data of the length bytewidth is read from the original data and a
     * multibyte is formed, if the hashtable contains the aforementioned
     * multibyte the keytable is searched for its index (key). If the data is is
     * not found in the hashtable the keytable will not have it either and the
     * data is not encoded. If a key is found it will be encoded in place of the
     * data. This method employs a form of run-length encoding: a prefix is
     * formed only when the current byte- width of the key differs from the
     * previous one, ie if keysize (in bytes) is different or no key is used.
     * Also multiple lengths of sequential unencoded data are encoded only one
     * prefix and it is changed only when the count reaches 86 or a key for data
     * is found.
     *
     * @param remainder
     * @return
     */
    private void encodeData(byte[] remainder) {

        encodedData = new byte[data.length];

        int bytesPerPreviousKey = -1;
        int bytesPerNextKey = 0;
        int runLength = 1;
        int prefixIndex = 0;
        int encodedDataIndex;
        boolean newPrefix = false;

        byte[] remainderWithPrefix = makeRemainderWithPrefix(remainder);
        encodedDataIndex = ArrayUtilities.encodeIntoArray(remainderWithPrefix, data, prefixIndex);
        prefixIndex = encodedDataIndex;
        encodedDataIndex++;

        for (int i = 0; i < data.length; i += byteWidth) {

            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                return;
            }

            MultiByte mb = ArrayUtilities.makeMultiByte(i, data, byteWidth);

            if (mb != null && hashTable.indexForMultiByte(mb) != null) {
                int keyInteger = getkey(mb);
                int thisKeyByteSize = IntegerConverter.getBytesPerInteger(keyInteger);
                byte[] keyBytes = IntegerConverter.IntegerToByte(keyInteger, thisKeyByteSize);
                thisKeyByteSize = keyBytes.length;

                if (thisKeyByteSize == bytesPerPreviousKey && runLength < 9) {
                    runLength++;
                } else {
                    bytesPerNextKey = thisKeyByteSize;
                    bytesPerPreviousKey = bytesPerPreviousKey == -1 ? thisKeyByteSize : bytesPerPreviousKey;
                    newPrefix = true;
                }

                encodedDataIndex = ArrayUtilities.encodeIntoArray(keyBytes, encodedData, encodedDataIndex);

            } else {
                if (bytesPerPreviousKey == 0 && runLength < 86) {
                    runLength++;
                } else {
                    bytesPerNextKey = 0;
                    bytesPerPreviousKey = bytesPerPreviousKey == -1 ? 0 : bytesPerPreviousKey;
                    newPrefix = true;
                }

                if (mb != null) {
                    encodedDataIndex = ArrayUtilities.encodeIntoArray(mb.getBytes(), encodedData, encodedDataIndex);
                } else {
                    newPrefix = true;
                }

            }

            if (newPrefix) {
                int prefixInt = generatePrefixInteger(bytesPerPreviousKey, runLength);

                byte prefix = IntegerConverter.IntegerToByte(prefixInt, 1)[0];
                encodedData[prefixIndex] = prefix;
                prefixIndex = encodedDataIndex;
                encodedDataIndex++;
                bytesPerPreviousKey = bytesPerNextKey;
                runLength = 1;

                newPrefix = false;
            }

        }

        encodedData = ArrayUtilities.removeTrailingZeros(encodedData, encodedDataIndex);
    }

    /**
     * Searches the key-table for the supplied MultiByte and returns its index
     * as key.
     *
     * @param mb
     * @return the index for the multibyte if found, -1 if not found which
     * should never happen.
     */
    private int getkey(MultiByte mb) {
        for (int i = 0; i < keys.length; i++) {
            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                break;
            }

            if (keys[i].equals(mb)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Introduces to the hash table multibytes of the size bytewidth.
     *
     * @return
     */
    private byte[] makeHashSet() {
        byte[] remainder = null;

        for (int i = 0; i < data.length; i += byteWidth) {
            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                break;
            }

            if (i + byteWidth - 1 < data.length) {
                MultiByte mb = ArrayUtilities.makeMultiByte(i, data, byteWidth);
                hashTable.put(mb);
            } else {
                remainder = new byte[data.length - i];
                for (int j = 0; j < remainder.length; j++) {
                    remainder[j] = data[i + j];   // if there is data left in the data-array, it is put in a new array and returned.
                }
            }
            if (interrupt) {
                this.status = StatusEnum.INTERRUPTED;
                break;
            }
        }
        return remainder;
    }

    /**
     * Calls the hashtable function to purge and clean keys that are not
     * referenced enough. Then purges from the set keys that would take more
     * space (table-entry + prefix + key) encoded than the data it encodes. This
     * is to guarantee that a key to be encoded will save at least 1 byte of
     * space when it is referenced at least the amount described below. A key to
     * be encoded will have a maximum of bytediwth-2 bytes, and the prefix for
     * data is in the worst case 1 byte. The reference count for any multibyte
     * is thus defined by the equation: bytewidth + 1, and the maximum number of
     * keys by: 2 ^ ( (bytewidth-2) *8 ).
     * @return true if there are more than zero keys false otherwise. There might
     * be zero keys if the data is almost random and not enough references are made
     * to any keys.
     */
    private boolean makeAndCleanKeys() {
        hashTable.purgeAndClean(byteWidth);
        if (hashTable.getKeyCount() > 0) {
            keys = hashTable.getArray(byteWidth);
            return true;
        }
        return false;
    }

    /**
     * Creates a bytearray of the keys stored in the global MultiByte array:
     * keys.
     *
     * @return
     */
    private void encodeKeys() {
        encodedKeys = new byte[keys.length * byteWidth];
        int encodeIndex = 0;
        for (int i = 0; i < keys.length; i++) {
            byte[] keyData = keys[i].getBytes();
            for (int j = 0; j < keyData.length; j++) {
                if (interrupt) {
                    this.status = StatusEnum.INTERRUPTED;
                    return;
                }

                encodedKeys[encodeIndex] = keyData[j];
                encodeIndex++;
            }
        }
    }

    /**
     * Generates an integer based on the bytewidth of previous key.
     *
     * @param bytesPerPreviousKey
     * @param runLength
     * @return an integer in the format: values 1 through 169 are reserved for
     * keys, first two digits represent byte-width of key, last the run-length;
     * values 170 through 255 are reserved for unencoded data, and represent
     * solely the running length for current bytewidth data. Currently the
     * maximum bytewidth for a key is limited to 16.
     */
    private int generatePrefixInteger(int bytesPerPreviousKey, int runLength) {
        int prefixInt;
        if (bytesPerPreviousKey == 0) {
            prefixInt = 169 + runLength;
        } else {
            prefixInt = bytesPerPreviousKey * 10 + runLength;
        }
        return prefixInt;
    }

    /**
     * Encodes the remainder of raw data into the begginning of the data.
     *
     * @param data
     * @param encodedDataIndex
     * @param prefixIndex
     * @return
     */
    private byte[] makeRemainderWithPrefix(byte[] remainder) {
        byte rawPrefix;
        byte[] remainderAndPrefix;
        if (remainder != null) {
            rawPrefix = IntegerConverter.IntegerToByte(remainder.length, 1)[0];
            remainderAndPrefix = new byte[1+remainder.length];
            remainderAndPrefix[0] = rawPrefix;
            for (int i = 1; i < remainderAndPrefix.length; i++) {
                remainderAndPrefix[i] = remainder[i-1];
            }
        } else {
            remainderAndPrefix = new byte[]{ new Byte("0") };
        }
        
        return remainderAndPrefix;
    }

    /**
     * Creates a header for the table in byte format. First byte is bytewidth, next bytes are
     * the size of the keytable and the last byte is zero denoting the end of the header.
     * @return 
     */
    private byte[] makeHeader() {
        byte byteWidthByte = IntegerConverter.IntegerToByte(byteWidth, 1)[0];
        
        int keyTableSizeByteCount = IntegerConverter.getBytesPerInteger(keys.length);
        byte[] keyTableSize = IntegerConverter.IntegerToByte(keys.length, keyTableSizeByteCount);
        
        byte[] header = new byte[keyTableSize.length + 2];
        header[0] = byteWidthByte;
        for (int i = 1; i < header.length-1; i++) {
            header[i] = keyTableSize[i-1];
        }
        header[header.length-1] = new Byte("0");
        
        return header;
    }

}
